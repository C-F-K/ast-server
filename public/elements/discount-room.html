<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/firebase-element/firebase-element.html">
<link rel="import" href="../bower_components/firebase-element/firebase-import.html">

<polymer-element name="discount-room">
	<template>
		<style type="text/css">
			#userconfig {
				display: block;
			} 

			label { 
			    display: inline-block; 
			    width: 8.75em; 
			    text-align: right; 
			}

			.selected {
				border: 1px solid white;
			}

			.singlecolor {
				transition: opacity 1s;
				-webkit-transition: opacity 1s;
				-moz-transition: opacity 1s;
				-o-transition: opacity 1s;
				opacity: 0.9;
				height: 24px;
				width: 24px;
				display: inline-block;
				margin-right: 6px;
			}
			#submit {
				display:inline-block;
			}

			#charblock {
				display:inline-block;
				width: 32em;
				vertical-align: text-top;
				padding-bottom:6px;
			}

			#colorblock {
				display:inline-block;
				width: 32em;
				vertical-align: text-top;
			}

			#buttoncontainer {
				display:inline-block;
				margin-left: 9.2em;
				margin-top: 0.5em;
			}

			table {
			    font-size: 8pt;
			    width:100%;
			    height:100%;
			    padding-left: auto;
			    padding-right: auto;
			}

			td {
			    width: 1.25%;
			    height: 2.2em;
			    text-align: center;
			    vertical-align: bottom;	
			}
		</style>
			<firebase-element 	id="firebase" 
								location="https://discount-app.firebaseio.com/" 
								data="{{data}}" 
								keys="{{keys}}"
								log
								childEvents								
								on-data-change={{dataChange}}
								on-child-added={{childAdded}}
								on-child-changed={{childChanged}}
								on-child-removed={{childRemoved}}>

			</firebase-element>
			<div id="userconfig">
				<label>Name:</label> 
				<input id="uname" type="text"></input><br>
				<label>Character:</label>
				<div id="charblock">
					<template repeat="{{ char in characters }}">
						<span id="{{char.name}}" class="possiblechar" on-click={{clickChar}}>{{char.chr}}</span>
					</template>
				</div><br>
				<label>Color:</label>
				<div id="colorblock">
					<template repeat="{{ color in palette }}">
						<div class="singlecolor" id="{{color}}" on-click={{fadeOthers}}></div>
					</template>

				</div>
				<br>
				<!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
				<div id="buttoncontainer">
					<button id="submit" on-click={{sendChar}}>Submit</button>
				</div>
				<!-- <button id="remove" on-click={{moveChar}}>Move</button> -->
			</div>
			<hr>
			<table> 
				<!-- Unlike RFK, the room has to exist independently of a putative user's desire to enter it. -->
				<!-- TODO: theoretical waffling on the ontology of the singleplayer/multiplayer binary -->
	        	<template repeat="{{ file in files }}">
	        	    <tr>
	        	        <template repeat="{{ rank in ranks }}">
	        	            <td id="{{file}}{{rank}}">{{ space }}</td>
	        	        </template>
	    	        </tr>
	    	    </template>
		    </table>
	</template>
	<script>
		// might need this function to check all keys for local user;
		// underscore could apparently do this elegantly but  
		// explicitly not using third-party libraries besides Polymer
		// for reasons which are not clear. probably masochism.
		// or maybe it's a more effective demonstration of web components
		// if I only use in-house shit. dunno.
		// Array.prototype.diff = function(a) {
		// 	return this.filter(function(i) {return a.indexOf(i) < 0;});
		// };

		Polymer('discount-room', {
			observe: {
			},
			characters: [
				{name:"a", chr:"a"}, 
				{name:"b", chr:"b"}, 
				{name:"c", chr:"c"}, 
				{name:"d", chr:"d"}, 
				{name:"e", chr:"e"}, 
				{name:"f", chr:"f"}, 
				{name:"g", chr:"g"}, 
				{name:"h", chr:"h"}, 
				{name:"i", chr:"i"}, 
				{name:"j", chr:"j"}, 
				{name:"k", chr:"k"}, 
				{name:"l", chr:"l"}, 
				{name:"m", chr:"m"}, 
				{name:"n", chr:"n"}, 
				{name:"o", chr:"o"}, 
				{name:"p", chr:"p"}, 
				{name:"q", chr:"q"}, 
				{name:"r", chr:"r"}, 
				{name:"s", chr:"s"}, 
				{name:"t", chr:"t"}, 
				{name:"u", chr:"u"}, 
				{name:"v", chr:"v"}, 
				{name:"w", chr:"w"}, 
				{name:"x", chr:"x"}, 
				{name:"y", chr:"y"}, 
				{name:"z", chr:"z"}, 
				{name:"A", chr:"A"}, 
				{name:"B", chr:"B"}, 
				{name:"C", chr:"C"}, 
				{name:"D", chr:"D"}, 
				{name:"E", chr:"E"}, 
				{name:"F", chr:"F"}, 
				{name:"G", chr:"G"}, 
				{name:"H", chr:"H"}, 
				{name:"I", chr:"I"}, 
				{name:"J", chr:"J"}, 
				{name:"K", chr:"K"}, 
				{name:"L", chr:"L"}, 
				{name:"M", chr:"M"}, 
				{name:"N", chr:"N"}, 
				{name:"O", chr:"O"}, 
				{name:"P", chr:"P"}, 
				{name:"Q", chr:"Q"}, 
				{name:"R", chr:"R"}, 
				{name:"S", chr:"S"}, 
				{name:"T", chr:"T"}, 
				{name:"U", chr:"U"}, 
				{name:"V", chr:"V"}, 
				{name:"W", chr:"W"}, 
				{name:"X", chr:"X"}, 
				{name:"Y", chr:"Y"}, 
				{name:"Z", chr:"Z"}, 
				{name:"zero", chr:"0"}, 
				{name:"one", chr:"1"}, 
				{name:"two", chr:"2"}, 
				{name:"three", chr:"3"}, 
				{name:"four", chr:"4"}, 
				{name:"five", chr:"5"}, 
				{name:"six", chr:"6"}, 
				{name:"seven", chr:"7"}, 
				{name:"eight", chr:"8"}, 
				{name:"nine", chr:"9"}, 
				{name:"colon", chr:":"},
				{name:"doublequote", chr: "\""}, 
				{name:"hash", chr: "#"}, 
				{name:"percent", chr:"%"}, 
				{name:"ampersand", chr: "&"}, 
				{name:"singlequote", chr:"\'"}, 
				{name:"openbracket", chr:"("}, 
				{name:"closebracket", chr:")"}, 
				{name:"asterisk", chr:"*"}, 
				{name:"plus", chr:"+"}, 
				{name:"comma", chr:","}, 
				{name:"hyphen", chr:"-"}, 
				{name:"period", chr:"."}, 
				{name:"slash", chr:"/"}, 
				{name:"semicolon", chr:";"}, 
				{name:"openanglebracket", chr:"<"}, 
				{name:"equals", chr:"="}, 
				{name:"closeanglebracket", chr:">"}, 
				{name:"question", chr:"?"}, 
				{name:"at", chr:"@"}, 
				{name:"opensquarebracket", chr:"["}, 
				{name:"backslash", chr:"\\"}, 
				{name:"closesquarebracket", chr:"]"}, 
				{name:"caret", chr:"^"}, 
				{name:"underscore", chr:"_"}, 
				{name:"accent", chr:"`"}, 
				{name:"opencurlybrace", chr:"{"}, 
				{name:"pipe", chr:"|"}, 
				{name:"closecurlybrace", chr:"}"}, 
				{name:"tilde", chr:"~"}
			],
			// character list cribbed shamelessly from robotfindskitten; painstakingly objectified it myself
			// this was necessary because "}" (for instance) is a valid element ID but "#}" is not a valid selector
			// so each item in the array of strings needed to become an object with the character 
			// AND a selector-compatible identifier
			palette: ["red", "yellow", "green", "blue", "cyan", "purple", "brown", "fuchsia", "greenyellow", "orange", "white", "gray"],
			selectedChar: "",
			selectedColor: "",
			ranks: [],
			files: ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x"],
			newfileup: 0,
			newfiledown: 0,
			newrankleft: 0,
			newrankright: 0,
			user: "",
			lastknownkeys: [],
			occupied: [],
			space: " ",

			ready: function (){
				// console.log(this.data + ":" + this.keys);
				// there was no _real_ need to do this programmatically but 
				// a) I was not in the mood to type out an array of 80 items
				// b) I wanted to make sure the template was repeating properly on arbitrary input
				for (i = 0; i < 80; i++) { 	// x-axis ranks 0 to 79
					this.ranks.push(i);		// y-axis files a to x (indices 0 to 23)
				}
				var boundOnKeyUp = this.onKeyUp.bind(this);
				var boundUserLeaves = this.userLeaves.bind(this);
				// var boundAboutToMove = this.aboutToMove.bind(this);
				document.addEventListener("keyup", boundOnKeyUp, false);
				// document.addEventListener("premove", boundAboutToMove, false);
				this.styleColorDivs();
				this.data = {};
				document.addEventListener("unload", boundUserLeaves, false);
			},

			userLeaves: function() {
				this.$.firebase.remove(this.user);
			},

			styleColorDivs: function(){
				var queryRoot = this.shadowRoot;
				// console.log(queryRoot);
				var resource = this.palette;
				// console.log(resource);
				for (var h = 0; h < this.palette.length; h++) {
					queryRoot.getElementById(resource[h]).style.background=resource[h];
					queryRoot.getElementById(resource[h]).style.opacity=0.9;
					// console.log(queryRoot.getElementById(resource[h]));
				} 
			},

			onKeyUp: function (evt) {
				// SO much bullshit wasted effort trying to get the element to talk to shit outside it
				// The document could hear the keyup but the element couldn't unless it was inside a text field
				// and then I needed the function to access the keyHandler object, which it wouldn't
				// so I eventually said "fuck it" and put the object inside the function.
				// This might not be best practices but a) IDGAF at this point and b) this appears to be the only way.
				// Friggin' encapsulation, I swear. Whose idea was this?
				// How is defining several levels of access not just making everyone's job harder?
				// Wikipedia says encapsulation is to prevent "unauthorized parties" accessing data
				// And ironically by bundling my handler object in the only function that needs it,
				// that seems to be what I've done.
				// But I think the principle gives your average unauthorized party WAY too much credit
				// (in the case of average users) or WAY not enough (in the case of people who can program).
				// frustrate++; sigh();

				// AGH!
				// next scope problem: referring to this.data[this.user] from within keyHandler.
				// the 'this' keyword (somewhat obviously in hindsight) refers to that object
				// and not to the one fed to Polymer().
				// I'm going to DRY this up and see if that helps.

				// NOPE, the problem is that the context ("this") of the key event is #document.
				// changed the listener's binding to window, see if that's it.
				// that caused more problems than it solved.

				// i need to change the context of onKeyUp to this Polymer() object,
				// which seems inevitably to require I know how to reference the damn thing.
				// except I don't seem to be able to. it's parsed at runtime.

				// NOPE AGAIN
				// the context is still inside the fukken keyhandler object.
				// I am moving all the handler properties to the main Polymer() object
				// because this is asinine.

				// don't code this early in the morning. (~5:45)
				// your logic is fine but your perceptions are skewed.

				// console.log("context:")
				// console.log(this);
				if (evt = evt ? evt : window.event ? event : null) {
					// console.log(evt.keyCode);
					// console.log("this inside:")
					// console.log(this);
					if (this[evt.keyCode]) {
						this[evt.keyCode]();
					}
				}
			},
				// if not at edge of room
				// 		and if newplace is not occupied
				// return true
				// if test is true then set rank and file to newrank and newfile
				// else don't change rank and file

			// keyHandler: {
				// undefined at property 'file', wtf?
				'37': function(){
					console.log("left");
					// console.log("file: " + this.data[this.user].file);
					// console.log("rank: " + this.data[this.user].rank);
					// console.log("rank after moving: " + this.newrankleft);
					var oldplace = this.data[this.user].file + this.data[this.user].rank;
					var newplace = this.data[this.user].file + this.newrankleft;
					if (this.canMove(newplace)) {
						// var payload = this.data[this.user];
						// this.fire('premove', payload);
						this.data[this.user].rank = this.newrankleft;
						this.$.firebase.commitProperty(this.user); 
					}
				},
				'38': function(){
					console.log("up");
					// console.log("file: " + this.data[this.user].file);
					// console.log("rank: " + this.data[this.user].rank);
					// console.log("file index after moving: " + this.newfileup);
					// console.log("file after moving: " + this.files[this.newfileup]);
					var oldplace = this.data[this.user].file + this.data[this.user].rank;
					var newplace = this.newfileup + this.data[this.user].rank;
					if (this.canMove(newplace)) {
						// var payload = this.data[this.user];
						// this.fire('premove', payload);
						this.data[this.user].file = this.files[this.newfileup];
						this.$.firebase.commitProperty(this.user);
					}
				},
				'39': function(){
					console.log("right");
					// console.log("file: " + this.data[this.user].file);
					// console.log("rank: " + this.data[this.user].rank);
					// console.log("rank after moving: " + this.newrankright);
					var oldplace = this.data[this.user].file + this.data[this.user].rank;
					var newplace = this.data[this.user].file + this.newrankright;
					if (this.canMove(newplace)) {
						// var payload = this.data[this.user];
						// this.fire('premove', payload);
						this.data[this.user].rank = this.newrankright;
						this.$.firebase.commitProperty(this.user);
					}
				},
				'40': function(){
					console.log("down");
					// console.log("file: " + this.data[this.user].file);
					// console.log("rank: " + this.data[this.user].rank);
					// console.log("file index after moving: " + this.newfiledown);
					// console.log("file after moving: " + this.files[this.newfiledown]);
					var oldplace = this.data[this.user].file + this.data[this.user].rank;
					var newplace = this.newfiledown + this.data[this.user].rank;
					if (this.canMove(newplace)) {
						// var payload = this.data[this.user];
						// this.fire('premove', payload);
						this.data[this.user].file = this.files[this.newfiledown];
						this.$.firebase.commitProperty(this.user);
					}
				},
			// },

			canMove: function(newplace) {
				if (this.occupied.indexOf(newplace) === -1) {
					return true;
				} else {
					return false;
				}
				// else {
				// 	var newrankleft = this.newrankleft;
				// 	var newfileup = this.newfileup;
				// 	var newrankright = this.newrankright;
				// 	var newfiledown = this.newfiledown;
				// 	var collisionHandler = {
				// 		'left': function() {
				// 			if (newrankleft >= 0) {
				// 				return false;
				// 			}
				// 		},
				// 		'up': function() {
				// 			if (newfileup >= 0) {
				// 				return false;
				// 			}
				// 		}, 
				// 		'right': function() {
				// 			if (newrankright >= 80) {
				// 				return false;
				// 			}
				// 		},
				// 		'down': function() {
				// 			if (newfiledown >= 24) {
				// 				return false;
				// 			}
				// 		}
				// 	};
				// 	if (collisionHandler[direction]) {
				// 		(collisionHandler[direction]);
				// 	} else {
				// 		return true;
				// 	}
				// }
			},
					// I could have done this with keys on a POJO like Jan Hein suggested
					// I do for the arrow key handlers, but after the grief that gave me
					// trying to get it to respond to the correct scope (and taking into account
					// the possibility that I might need to declare ie. 'left' on my Polymer()
					// object before I'm done) there's no way in hell I'm doing that shit
					// intentionally ever again within a Polymer element.
					// notional hierarchy of multi-conditionals:
					// POJOkeys > else ifs > switch/case

			clickChar: function(el) {
				// console.log(el.toElement.id);
				// console.log (el.toElement.className);
				if (el.toElement.className == "possiblechar selected") { // check if the clicked element is selected
					return false;
				} else {
					var clickedId = "#" + el.toElement.id; // get selectable string of templated ID
					var queried = this.shadowRoot;		// dump this shit
					var resource = this.characters;		// into variables
					var preselect = "";					// outside the scope of the for loop
					// console.log(this.shadowRoot.querySelector(clickedId).className);
					// console.log(this.shadowRoot.querySelectorAll(".possiblechar").array());
					// console.log(this.characters);
					for (var i = 0; i < resource.length; i++) { // reset all classnames to just "possiblechar"
						// console.log(queried.querySelector(".possiblechar"));
						var itr = "#" + resource[i].name;
						// console.log(itr);
						queried.querySelector(itr).className = "possiblechar";
					}
					var clicked = this.shadowRoot.querySelector(clickedId); // query clicked element using string
					clicked.className = clicked.className + " selected"; // add "selected" to queried el's class
					var slicedId = clickedId.substring(1); // shave off the # again
					for (var j = 0; j < resource.length; j++) { // look through the list for the appropriate char
						if (resource[j].name == slicedId) { // (necessary because of the id/selector clusterfuck)
							preselect = resource[j].chr; // this seems inelegant somehow though
						}
					}
					this.selectedChar = preselect; // tell Polymer about it
					// console.log(this.selectedChar);
					// console.log(this.shadowRoot.querySelector(clickedId).className);
				}
			},

			fadeOthers: function(e){
				// console.log(e.toElement.id);
				// var payloadId = e.toElement.id;
				// var clickedId = "#" + payloadId;
				// console.log(clickedId);
				// var queriedNode = this.shadowRoot;
				// console.log(queriedNode.querySelector(clickedId));
				// console.log(queriedNode.getElementById(clickedId));
				// this and clickChar could potentially be refactored into a single click handler
				// but initial experience seems to suggest that would result in scope problems.
				// I blame Polymer. 
				var resource = this.palette;
				// console.log(resource);
				for (var k = 0; k < this.palette.length; k++){
					// var itr = "#" + this.palette[k];
					// console.log("setting " + itr + " to 0.3");
					this.shadowRoot.getElementById(this.palette[k]).style.opacity=0.3;
					// queriedEl.style.color=resource[k];
				}
				this.shadowRoot.getElementById(e.toElement.id).style.opacity=1;
				this.selectedColor = e.toElement.id;
				// console.log(this.selectedColor);
			},

			sendChar: function(){
				var unm = this.$.uname.value;
				var uchr = this.selectedChar;
				var uclr = this.selectedColor; 
				if (uchr == "" || unm == "" || uclr == "") {
					alert("Need a name, character and color");
					return false;
				} else {
					this.lastknownkeys = this.keys;
					console.log(this.lastknownkeys);
					this.$.firebase.push({
						rank: Math.floor(Math.random() * (this.ranks.length - 1)),
						file: this.files[Math.floor(Math.random() * (this.files.length - 1))],
						chr: uchr,
						clr: uclr,
						name: unm
					});
				}
				this.shadowRoot.querySelector("#userconfig").style.display="none";
				// after dicking around for way too long trying to register a user and make sure there was only 1
				// I realized "I am thinking about this from the wrong end of the process" - 
				// there's no need to check unity programmatically if I just disable the user's ability to
				// create more characters after they create their first one.
			},

			dataChange: function() {
				if (this.user == "") {
					console.log("you are not yet in the room");
				} else {
					var place = this.data[this.user].file + this.data[this.user].rank;
					console.log("your position is " + place);
					// convert file to number
					// then increment/decrement everything
					// i'm an asshole and forgot that the numbers are INTEGERS
					// and therefore I didn't have to re-get indexOf when moving.
					var filenum = this.files.indexOf(this.data[this.user].file)
					this.newfiledown = filenum;
					this.newfiledown++;
					this.newfileup = filenum;
					this.newfileup--;
					this.newrankleft = this.data[this.user].rank;
					this.newrankleft--;
					this.newrankright = this.data[this.user].rank;
					this.newrankright++;
				}
			},

			childAdded: function(e){
				if (this.user == "") { // how the seven hells did it take me this long 
					this.user = e.detail.name;
					console.log('you have been assigned uID ' + this.user);
				}
				var place = '#' + e.detail.value.file + e.detail.value.rank;
				var child = this.shadowRoot.querySelector(place);
				// console.log('placing ' + e.detail.value.chr + ' at ' + place);
				child.innerHTML = e.detail.value.chr;
				child.style.color=e.detail.value.clr;
				this.occupied.push(place.substring(1));
				console.log("user " + e.detail.value.name + " has entered the room at " + place.substring(1));
				// totally violating DRY here but IDGAF tbqh
				var strungUID = "data." + e.detail.name;
				this.observe[strungUID] = 'dataChange';
			},

			// aboutToMove: function(e){
			// 	var oldplace = this.data[e.detail.name].file + this.data[e.detail.name].rank;
			// 	console.log("about to move");
			// 	console.log("old place: " + oldplace)
				// TODO: grab old place data
				// grab new place data (innerHTML of new place data is necessarily " ")
				// switch the two around
			// },

			childChanged: function(e) {
				var place = this.lastknownplace;
				this.occupied.splice(this.occupied.indexOf(place), 1);
				var newplace = e.detail.value.file + e.detail.value.rank;
				this.occupied.push(newplace);
			},

			childRemoved: function(e) {
				var place = e.detail.value.file + e.detail.value.rank;
				this.occupied.splice(this.occupied.indexOf(place), 1);
				this.shadowRoot.getElementById(place).innerHTML = this.space;
				console.log("user " + e.detail.value.name + " has left the room");
			}
		});
	</script>
</polymer-element>