<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/firebase-element/firebase-element.html">
<link rel="import" href="../bower_components/firebase-element/firebase-import.html">

<polymer-element name="discount-room">
	<template>
		<style type="text/css">
			#userconfig {
				display: block;
			} 

			label { 
			    display: inline-block; 
			    width: 8.75em; 
			    text-align: right; 
			}

			.selected {
				border: 1px solid white;
			}

			#submit {
				display:inline-block;
			}

			#charblock {
				display:inline-block;
				width: 32em;
				vertical-align: text-top;
			}

			#buttoncontainer {
				display:inline-block;
				margin-left: 8.75em;
				margin-top: 0.5em;
			}

			table {
			    font-size: 8pt;
			    width:100%;
			    height:100%;
			    padding-left: auto;
			    padding-right: auto;
			}

			td {
			    width: 1.25%;
			    height: 2.2em;
			    /*border: 1px solid white;*/
			    text-align: center;
			    vertical-align: bottom;	
			}

		</style>
			<firebase-element 	id="firebase" 
								location="https://discount-app.firebaseio.com/" 
								data="{{data}}" 
								keys="{{keys}}"
								log
								childEvents
								on-child-added={{childAdded}}
								on-data-change={{update}}>
			</firebase-element>
			<div id="userconfig">
				<label>Name:</label> <input id="uname" type="text"></input><br>
				<label>Character:</label>
				<div id="charblock">
					<template repeat="{{ char in characters }}">
						<span id="{{char.name}}" class="possiblechar" on-click={{clickChar}}>{{char.chr}}</span>
					</template>
				</div>
				<br>
				<!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
				<div id="buttoncontainer">
					<button id="submit" on-click={{sendChar}}>Submit</button>
				</div>
				<!-- <button id="remove" on-click={{moveChar}}>Move</button> -->
			</div>
			<hr>
			<table>
				<!-- Unlike RFK, the room has to exist independently of a putative user's desire to enter it. -->
				<!-- TODO: theoretical waffling on the ontology of the singleplayer/multiplayer binary -->
	        	<template repeat="{{ file in files }}">
	        	    <tr>
	        	        <template repeat="{{ rank in ranks }}">
	        	            <td id="{{file}}{{rank}}">{{ space }}</td>
	        	        </template>
	    	        </tr>
	    	    </template>
		    </table>
	</template>
	<script>
		Polymer('discount-room', {
			// observe: {
			// 	data: 'dataChanged'
			// },
			registeredUser: "",
			characters: [
				{name:"a", chr:"a"}, 
				{name:"b", chr:"b"}, 
				{name:"c", chr:"c"}, 
				{name:"d", chr:"d"}, 
				{name:"e", chr:"e"}, 
				{name:"f", chr:"f"}, 
				{name:"g", chr:"g"}, 
				{name:"h", chr:"h"}, 
				{name:"i", chr:"i"}, 
				{name:"j", chr:"j"}, 
				{name:"k", chr:"k"}, 
				{name:"l", chr:"l"}, 
				{name:"m", chr:"m"}, 
				{name:"n", chr:"n"}, 
				{name:"o", chr:"o"}, 
				{name:"p", chr:"p"}, 
				{name:"q", chr:"q"}, 
				{name:"r", chr:"r"}, 
				{name:"s", chr:"s"}, 
				{name:"t", chr:"t"}, 
				{name:"u", chr:"u"}, 
				{name:"v", chr:"v"}, 
				{name:"w", chr:"w"}, 
				{name:"x", chr:"x"}, 
				{name:"y", chr:"y"}, 
				{name:"z", chr:"z"}, 
				{name:"A", chr:"A"}, 
				{name:"B", chr:"B"}, 
				{name:"C", chr:"C"}, 
				{name:"D", chr:"D"}, 
				{name:"E", chr:"E"}, 
				{name:"F", chr:"F"}, 
				{name:"G", chr:"G"}, 
				{name:"H", chr:"H"}, 
				{name:"I", chr:"I"}, 
				{name:"J", chr:"J"}, 
				{name:"K", chr:"K"}, 
				{name:"L", chr:"L"}, 
				{name:"M", chr:"M"}, 
				{name:"N", chr:"N"}, 
				{name:"O", chr:"O"}, 
				{name:"P", chr:"P"}, 
				{name:"Q", chr:"Q"}, 
				{name:"R", chr:"R"}, 
				{name:"S", chr:"S"}, 
				{name:"T", chr:"T"}, 
				{name:"U", chr:"U"}, 
				{name:"V", chr:"V"}, 
				{name:"W", chr:"W"}, 
				{name:"X", chr:"X"}, 
				{name:"Y", chr:"Y"}, 
				{name:"Z", chr:"Z"}, 
				{name:"zero", chr:"0"}, 
				{name:"one", chr:"1"}, 
				{name:"two", chr:"2"}, 
				{name:"three", chr:"3"}, 
				{name:"four", chr:"4"}, 
				{name:"five", chr:"5"}, 
				{name:"six", chr:"6"}, 
				{name:"seven", chr:"7"}, 
				{name:"eight", chr:"8"}, 
				{name:"nine", chr:"9"}, 
				{name:"colon", chr:":"},
				{name:"doublequote", chr: "\""}, 
				{name:"hash", chr: "#"}, 
				{name:"percent", chr:"%"}, 
				{name:"ampersand", chr: "&"}, 
				{name:"singlequote", chr:"\'"}, 
				{name:"openbracket", chr:"("}, 
				{name:"closebracket", chr:")"}, 
				{name:"asterisk", chr:"*"}, 
				{name:"plus", chr:"+"}, 
				{name:"comma", chr:","}, 
				{name:"hyphen", chr:"-"}, 
				{name:"period", chr:"."}, 
				{name:"slash", chr:"/"}, 
				{name:"semicolon", chr:";"}, 
				{name:"openanglebracket", chr:"<"}, 
				{name:"equals", chr:"="}, 
				{name:"closeanglebracket", chr:">"}, 
				{name:"question", chr:"?"}, 
				{name:"at", chr:"@"}, 
				{name:"opensquarebracket", chr:"["}, 
				{name:"backslash", chr:"\\"}, 
				{name:"closesquarebracket", chr:"]"}, 
				{name:"caret", chr:"^"}, 
				{name:"underscore", chr:"_"}, 
				{name:"accent", chr:"`"}, 
				{name:"opencurlybrace", chr:"{"}, 
				{name:"pipe", chr:"|"}, 
				{name:"closecurlybrace", chr:"}"}, 
				{name:"tilde", chr:"~"}
			],
			// character list cribbed shamelessly from robotfindskitten; painstakingly objectified it myself
			// this was necessary because "}" (for instance) is a valid element ID but "#}" is not a valid selector
			// so each item in the array of strings needed to become an object with the character 
			// AND a selector-compatible identifier
			selectedChar: "",
			ranks: [],
			files: ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x"],
			newfileleft: 0,
			newfileright: 0,
			newrankup: 0,
			newrankdown: 0,
			occupied: [],
			space: ".",

			ready: function (){
				// console.log(this.data + ":" + this.keys);
				for (i = 0; i < 80; i++) {
					this.ranks.push(i);
				}
				document.addEventListener("keyup", this.onKeyUp, false);
			},

			onKeyUp: function (evt) {
				// SO much bullshit wasted effort trying to get the element to talk to shit outside it
				// The document could hear the keyup but the element couldn't unless it was inside a text field
				// and then I needed the function to access the keyHandler object, which it wouldn't
				// so I eventually said "fuck it" and put the object inside the function.
				// This might not be best practices but a) IDGAF at this point and b) this appears to be the only way.
				// Friggin' encapsulation, I swear. Whose idea was this?
				// How is defining several levels of access not just making everyone's job harder?
				// Wikipedia says encapsulation is to prevent "unauthorized parties" accessing data
				// And ironically by bundling my handler object in the only function that needs it,
				// that seems to be what I've done.
				// But I think the principle gives your average unauthorized party WAY too much credit
				// (in the case of average users) or WAY not enough (in the case of people who can program).
				// frustrate++; sigh();
				var keyHandler = {
					37: function(){
						console.log("left");
					},
					38: function(){
						console.log("up");
					},
					39: function(){
						console.log("right");
					},
					40: function(){
						console.log("down");
					}
				};
				if (evt = evt ? evt : window.event ? event : null) {
					// console.log(evt.keyCode);
					if (keyHandler[evt.keyCode]) {
						keyHandler[evt.keyCode]();
					}
				}
			},

			clickChar: function(el) {
				// console.log(el.toElement.id);
				// console.log (el.toElement.className);
				if (el.toElement.className == "possiblechar selected") { // check if the clicked element is selected
					return false;
				} else {
					var clickedId = "#" + el.toElement.id; // get selectable string of templated ID
					var queried = this.shadowRoot;
					var resource = this.characters;
					var preselect = "";
					// console.log(this.shadowRoot.querySelector(clickedId).className);
					// console.log(this.shadowRoot.querySelectorAll(".possiblechar").array());
					// console.log(this.characters);
					for (var i = 0; i < resource.length; i++) { // reset all classnames to just "possiblechar"
						// console.log(queried.querySelector(".possiblechar"));
						var itr = "#" + resource[i].name;
						// console.log(itr);
						queried.querySelector(itr).className = "possiblechar";
					}
					var clicked = this.shadowRoot.querySelector(clickedId); // query clicked element using string
					clicked.className = clicked.className + " selected"; // add "selected" to queried el's class
					var slicedId = clickedId.substring(1); // shave off the # again
					for (var j = 0; j < resource.length; j++) { // look through the list for the appropriate char
						if (resource[j].name == slicedId) { // (necessary because of the id/selector clusterfuck)
							preselect = resource[j].chr; // this seems inelegant somehow though
						}
					}
					this.selectedChar = preselect; // tell Polymer about it
					// console.log(this.selectedChar);
					// console.log(this.shadowRoot.querySelector(clickedId).className);
				}
			},

			sendChar: function(){
				var unm = this.$.uname.value;
				var uchr = this.selectedChar
				if (uchr == "" || unm == "") {
					alert("Need a name and a character");
				} else {
					this.$.firebase.push({
						rank: Math.floor(Math.random() * this.ranks.length),
						file: this.files[Math.floor(Math.random() * this.files.length)],
						chr: uchr,
						name: unm
					});
				}
				this.shadowRoot.querySelector("#userconfig").style.display="none";
			},

			childAdded: function(e){
				var place = '#' + e.detail.value.file + e.detail.value.rank;
				// console.log('placing ' + e.detail.value.chr + ' at ' + place);
				this.shadowRoot.querySelector(place).innerHTML = e.detail.value.chr;
				
				// if (this.registeredUser == "") {
				// 	console.log("setting username to: " + e.detail.name);
				// 	this.registeredUser = e.detail.name;

				// } else {
				// 	console.log("user already present");
				// }
				// console.log(e.detail.name);
				// console.log(this.registeredUser);
				// console.log(e.detail.value);
			},

			update: function(p){
				// console.log("fuck");
				// console.log(p);
			}

		});
	</script>
</polymer-element>

sendchar: disable user config part (above the HR)


	$(document).keydown(function(key) {
		switch(parseInt(key.which,10)) {
			case 37:
				//left
				disCount.child('user').child('posx').set(newposxleft);
				//$('img').animate({left: "-=10px"}, 'fast');
				break;
			case 40:
				//down
				disCount.child('user').child('posy').set(newposydown);
				//$('img').animate({top: "+=10px"}, 'fast');
				break;
			case 38:
				//up
				disCount.child('user').child('posy').set(newposyup);
				//$('img').animate({top: "-=10px"}, 'fast');
				break;
			case 39:
				//right				
				disCount.child('user').child('posx').set(newposxright);
				//$('img').animate({left: "+=10px"}, 'fast');
				break;
			case 82:
				// press 'r' to attempt to write roomContents to room div
				concreteRoom();
			default:
				break;
		}
	});	
});

			dataChanged: function(snap){
				console.log(snap);
				if (snap.detail.value === null) {
					console.log("no user yet");
				} else {
					for (key in snap.detail) {
						var name = snap.detail.name;
						console.log("position is " + snap.detail.value.name.file + "," + snap.detail.value.name.rank);
						this.newposxleft = snap.detail.value.name.file;
						this.newposxleft--;
						this.newposxright = snap.detail.value.name.file;
						this.newposxright++;
						this.newposyup = snap.detail.value.name.rank;
						this.newposyup--;
						this.newposydown = snap.detail.value.name.rank;
						this.newposydown++;
					}
				}
			},
