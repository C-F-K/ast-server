<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/firebase-element/firebase-element.html">
<link rel="import" href="../bower_components/firebase-element/firebase-import.html">

<polymer-element 	name="discount-room"
					on-keyup="{{handleKey}}">
	<template>
		<style type="text/css">
			label { 
			    display: inline-block; 
			    width: 140px; 
			    text-align: right; 
			}â€‹

			.selected {
				border: 1px solid white;
			}

			#submit {
				display:inline-block;
			}

			table {
			    font-size: 8pt;
			    width:100%;
			    height:100%;
			    padding-left: auto;
			    padding-right: auto;
			}

			td {
			    width: 1.25%;
			    height: 2.2em;
			    /*border: 1px solid white;*/
			    text-align: center;
			    vertical-align: bottom;	
			}
		</style>
			<firebase-element 	id="firebase" 
								location="https://discount-app.firebaseio.com/" 
								data="{{data}}" 
								keys="{{keys}}"
								log
								childEvents
								on-child-added="{{childAdded}}">
			</firebase-element>
			<label>Name:</label> <input id="uname" type="text"></input><br>
			<label>Character:</label>
			<template repeat="{{ char in characters }}">
				<span id="{{char}}" on-click="{{clickChar}}">{{char}}</span>
			</template>
			<br>
			<!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
			<button id="submit" on-click={{sendChar}}>Submit</button>
			<!-- <button id="remove" on-click={{moveChar}}>Move</button> -->
			<hr>
			<table>
				<!-- Unlike RFK, the room has to exist independently of a putative user's desire to enter it. -->
				<!-- TODO: theoretical waffling on the ontology of the singleplayer/multiplayer binary -->
	        	<template repeat="{{ file in files }}">
	        	    <tr>
	        	        <template repeat="{{ rank in ranks }}">
	        	            <td id="{{file}}{{rank}}">{{ space }}</td>
	        	        </template>
	    	        </tr>
	    	    </template>
		    </table>
	</template>
	<script>
		Polymer('discount-room', {
			// observe: {
			// 	data: 'dataChanged'
			// },
			characters: ["\"", "#", "%", "&", "\'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~"],
			// cribbed shamelessly from robotfindskitten
			ranks: [],
			files: ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x"],
			newfileleft: 0,
			newfileright: 0,
			newrankup: 0,
			newrankdown: 0,
			occupied: [],
			space: ".",

			ready: function (){
				// console.log(this.data + ":" + this.keys);
				for (i = 0; i < 80; i++) {
					this.ranks.push(i);
				}
				document.addEventListener("keyup", this.onKeyUp, false);
			},

			onKeyUp: function (evt) {
				// SO much bullshit wasted effort trying to get the element to talk to shit outside it
				// The document could hear the keyup but the element couldn't unless it was inside a text field
				// and then I needed the function to access the keyHandler object, which it wouldn't
				// so I eventually said "fuck it" and put the object inside the function.
				// This might not be best practices but a) IDGAF at this point and b) this appears to be the only way.
				// Friggin' encapsulation, I swear. Whose idea was this?
				// How is defining several levels of access not just making everyone's job harder?
				// Wikipedia says encapsulation is to prevent "unauthorized parties" accessing data
				// And ironically by bundling my handler object in the only function that needs it,
				// that seems to be what I've done.
				// But I think the principle gives your average unauthorized party WAY too much credit
				// (in the case of average users) or WAY not enough (in the case of people who can program).
				// frustrate++; sigh();
				var keyHandler = {
					37: function(){
						// console.log("left");
					},
					38: function(){
						// console.log("up");
					},
					39: function(){
						// console.log("right");
					},
					40: function(){
						// console.log("down");
					}
				};
				if (evt = evt ? evt : window.event ? event : null) {
					// console.log(evt.keyCode);
					if (keyHandler[evt.keyCode]) {
						keyHandler[evt.keyCode]();
					}
				}
			},

			clickChar: function() {
				var select = this.shadowRoot.querySelector("")
				console.log(this.characters.indexOf(select));
			},

			handleKey: function(key){
				if (this.keyHandler[key.keyCode]) {
					this.keyHandler[key.keyCode]();
				}
			},

			sendChar: function(){
				var uchr = this.$.uchar.value;
				var unm = this.$.uname.value;
				if (uchr == "" || unm == "") {
					alert("Need a name and a character");
				} else if (uchr.length > 1) {
					alert("Need only one character")
				// } else if () {

				// }
				} else {
					this.$.firebase.push({
						rank: Math.floor(Math.random() * this.ranks.length),
						file: this.files[Math.floor(Math.random() * this.files.length)],
						chr: uchr,
						name: unm
					});
				}
			},

			childAdded: function(e){
				var place = '#' + e.detail.value.file + e.detail.value.rank;
				// console.log('placing ' + e.detail.value.chr + ' at ' + place);
				this.shadowRoot.querySelector(place).innerHTML = e.detail.value.chr;	
			},

			update: function(e){

			}

		});
	</script>
</polymer-element>

	$(document).keydown(function(key) {
		switch(parseInt(key.which,10)) {
			case 37:
				//left
				disCount.child('user').child('posx').set(newposxleft);
				//$('img').animate({left: "-=10px"}, 'fast');
				break;
			case 40:
				//down
				disCount.child('user').child('posy').set(newposydown);
				//$('img').animate({top: "+=10px"}, 'fast');
				break;
			case 38:
				//up
				disCount.child('user').child('posy').set(newposyup);
				//$('img').animate({top: "-=10px"}, 'fast');
				break;
			case 39:
				//right				
				disCount.child('user').child('posx').set(newposxright);
				//$('img').animate({left: "+=10px"}, 'fast');
				break;
			case 82:
				// press 'r' to attempt to write roomContents to room div
				concreteRoom();
			default:
				break;
		}
	});	
});

			dataChanged: function(snap){
				console.log(snap);
				if (snap.detail.value === null) {
					console.log("no user yet");
				} else {
					for (key in snap.detail) {
						var name = snap.detail.name;
						console.log("position is " + snap.detail.value.name.file + "," + snap.detail.value.name.rank);
						this.newposxleft = snap.detail.value.name.file;
						this.newposxleft--;
						this.newposxright = snap.detail.value.name.file;
						this.newposxright++;
						this.newposyup = snap.detail.value.name.rank;
						this.newposyup--;
						this.newposydown = snap.detail.value.name.rank;
						this.newposydown++;
					}
				}
			},
